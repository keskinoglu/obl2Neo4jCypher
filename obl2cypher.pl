/*  Part of SWI-Prolog

    Author:        Tolga Keskinoglu
    E-mail:        viva.tolga@gmail.com

*/

/*
    USAGE

    Reads a .obl file generated by the SciMod of OntoBroker
    and writes Neo4j Cpypher to create nodes and edges for
    the Entity, Relation, and Event frames.

    Run using write_matches_to_file('InputFile.obl', 'OutputFile.txt').

*/

:- consult('obl_grammar.pl').
:- use_module(library(dcg/basics)).

% TODO: optimize checking for the last obl_frame of its kind. Or find an alternative
% method to resolve the "no comma" for the last row in parse_obl (below).
% no_more... clauses are probably not the most efficient way to go about this.
% It checks the entire file until the end for each obl_frame it encounters.
no_more_entity_frames -->
    eos
    | "\n", obl_frame("Event", _, _, _, _), no_more_entity_frames
    | "\n", obl_frame("Relation", _, _, _, _), no_more_entity_frames.

more_entity_frames --> % Not used. An attempt at optimizing parsing.
      "\n", obl_frame("Entity", _, _, _, _), {true}
    | "\n", obl_frame(_, _, _, _, _), more_entity_frames.

no_more_event_frames -->
    eos
    | "\n", obl_frame("Entity", _, _, _, _), no_more_event_frames
    | "\n", obl_frame("Relation", _, _, _, _), no_more_event_frames.

no_more_relation_frames -->
    eos
    | "\n", obl_frame("Entity", _, _, _, _), no_more_relation_frames
    | "\n", obl_frame("Event", _, _, _, _), no_more_relation_frames.


parse_obl_entities -->
    obl_frame("Entity", O, C, S, _), no_more_entity_frames, % If there are no more entity frames...
    {   % a comma should not be present.
        format('  {object: toLower("~s"), class: toLower("~s"), super: toLower("~s")}~n', [O,C,S])
    }, !
    |
    obl_frame("Entity", O, C, S, _),
    {   % Otherwise a comma is needed between cypher row statements.
        format('  {object: toLower("~s"), class: toLower("~s"), super: toLower("~s")},~n', [O,C,S])
    }
    |
    [_],  % Skip one token
    parse_obl_entities.  % Continue parsing


parse_obl_events -->
    obl_frame("Event", E, S, _, _), no_more_event_frames, % If there are no more event frames...
    {   % a comma should not be present.
        format('  {event: toLower("~s"), story: toLower("~s")}~n', [E,S])
    }, !
    |
    obl_frame("Event", E, S, _, _),
    {
        format('  {event: toLower("~s"), story: toLower("~s")},~n', [E,S])
    }
    |
    [_],  % Skip one token
    parse_obl_events.  % Continue parsing

parse_obl_relations -->
    obl_frame("Relation", R, RC, _, [["entityAOBL", EntityA], ["entityBOBL", EntityB] | _]), no_more_relation_frames, % If there are no more relation frames...
    {   % a comma should not be present.
        format('  {relation: toLower("~s"), relation_class: toLower("~s"), entity_a: toLower("~s"), entity_b: toLower("~s")}~n', [R, RC, EntityA, EntityB])
    }, !
    |
    obl_frame("Relation", R, RC, _, [["entityAOBL", EntityA], ["entityBOBL", EntityB] | _]),
    {
        format('  {relation: toLower("~s"), relation_class: toLower("~s"), entity_a: toLower("~s"), entity_b: toLower("~s")},~n', [R, RC, EntityA, EntityB])
    }
    |
    [_],  % Skip one token
    parse_obl_relations.  % Continue parsing

% Main
write_matches_to_file(InputFile, OutputFile) :-
    open(OutputFile, write, OutStream),

    % Entities
    format(OutStream, 'UNWIND [~n', []),
    with_output_to(OutStream, phrase_from_file(parse_obl_entities, InputFile)),
    format(OutStream, '] AS triple~n', []),
    format(OutStream, 'MERGE (o:Entity:EntityObject {name: triple.object})~n', []),
    format(OutStream, 'MERGE (c:Entity:EntityClass {name: triple.class})~n', []),
    format(OutStream, 'MERGE (s:Entity:EntitySuperClass {name: triple.super})~n', []),
    format(OutStream, 'WITH DISTINCT o, c, s~n', []),
    format(OutStream, 'MERGE (o)-[:IS_AN_INSTANCE_OF]->(c)~n', []),
    format(OutStream, 'MERGE (c)-[:IS_A_TYPE_OF]->(s);~n~n', []),

    % Events
    format(OutStream, 'UNWIND [~n', []),
    with_output_to(OutStream, phrase_from_file(parse_obl_events, InputFile)),
    format(OutStream, '] AS pair~n', []),
    format(OutStream, 'MERGE (e:Event:EventObject {name: pair.event})~n', []),
    format(OutStream, 'MERGE (s:Event:EventClass {name: pair.story})~n', []),
    format(OutStream, 'MERGE (e)-[:IS_AN_INSTANCE_OF]->(s);~n~n', []),

    % TODO: check if ther's a way to do both using a single parse_obl_relations.

    % Relations (Option 2) a-->b
    format(OutStream, 'UNWIND [~n', []),
    with_output_to(OutStream, phrase_from_file(parse_obl_relations, InputFile)),
    format(OutStream, '] AS quartet~n', []),
    format(OutStream, 'MERGE (a:Relation:RelationEntityA {name: quartet.entity_a})~n', []),
    format(OutStream, 'MERGE (b:Relation:RelationEntityB {name: quartet.entity_b})~n', []),
    format(OutStream, 'WITH DISTINCT a, b~n', []),
    format(OutStream, 'MERGE (a)-[:IS_RELATED_TO]->(b);~n~n', []),

    % Relations (Option 1)
    format(OutStream, 'UNWIND [~n', []),
    with_output_to(OutStream, phrase_from_file(parse_obl_relations, InputFile)),
    format(OutStream, '] AS quartet~n', []),
    format(OutStream, 'CREATE (r:Relation:RelationObject {name: quartet.relation})~n', []),
    format(OutStream, 'MERGE (rc:Relation:RelationClass {name: quartet.relation_class})~n', []),
    format(OutStream, 'MERGE (a:Relation:RelationEntityA {name: quartet.entity_a})~n', []),
    format(OutStream, 'MERGE (b:Relation:RelationEntityB {name: quartet.entity_b})~n', []),
    format(OutStream, 'WITH DISTINCT r, rc, a, b~n', []),
    format(OutStream, 'MERGE (r)-[:IS_AN_INSTANCE_OF]->(rc)~n', []),
    format(OutStream, 'MERGE (r)-[:IS_RELATED_TO]->(a)~n', []),
    format(OutStream, 'MERGE (r)-[:IS_RELATED_TO]->(b);~n', []),

    close(OutStream).

